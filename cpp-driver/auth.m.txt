//
//  auth.m
//  cpp-driver
//
//  Created by Philippe on 20/10/2017.
//  Copyright Â© 2017 PLB. All rights reserved.
//

#include <cassandra.h>

#include <stdio.h>
#include <string.h>

typedef struct Credentials_ {
    const char* password;
    const char* username;
} Credentials;

void on_auth_initial(CassAuthenticator* auth,
                     void* data) {
    /*
     * This callback is used to initiate a request to begin an authentication
     * exchange. Required resources can be acquired and initialized here.
     *
     * Resources required for this specific exchange can be stored in the
     * auth->data field and will be available in the subsequent challenge
     * and success phases of the exchange. The cleanup callback should be used to
     * free these resources.
     */
    printf("on_auth_initial\n");

    /*
     * The data parameter contains the credentials passed in when the
     * authentication callbacks were set and is available to all
     * authentication exchanges.
     */
    const Credentials* credentials = (const Credentials *)data;

    size_t username_size = strlen(credentials->username);
    size_t password_size = strlen(credentials->password);
    size_t size = username_size + password_size + 2;

    char* response = cass_authenticator_response(auth, size);

    /* Credentials are prefixed with '\0' */
    response[0] = '\0';
    memcpy(response + 1, credentials->username, username_size);

    response[username_size + 1] = '\0';
    memcpy(response + username_size + 2, credentials->password, password_size);
}

void on_auth_challenge(CassAuthenticator* auth,
                       void* data,
                       const char* token,
                       size_t token_size) {
    /*
     * Not used for plain text authentication, but this is to be used
     * for handling an authentication challenge initiated by the server.
     */
    printf("on_auth_challenge\n");
}

void on_auth_success(CassAuthenticator* auth,
                     void* data,
                     const char* token,
                     size_t token_size ) {
    /*
     * Not used for plain text authentication, but this is to be used
     * for handling the success phase of an exchange.
     */
    printf("on_auth_success\n");
}

void on_auth_cleanup(CassAuthenticator* auth, void* data) {
    /*
     * No resources cleanup is necessary for plain text authentication, but
     * this is used to cleanup resources acquired during the authentication
     * exchange.
     */
    printf("on_auth_cleanup\n");
}

/*
int main(int argc, char* argv[]) {
    // Setup and connect to cluster
    CassFuture* connect_future = NULL;
    CassCluster* cluster = cass_cluster_new();
    CassSession* session = cass_session_new();
    char* hosts = "127.0.0.1,127.0.0.2,127.0.0.3";

    // Setup authentication callbacks and credentials
    CassAuthenticatorCallbacks auth_callbacks = {
        on_auth_initial,
        on_auth_challenge,
        on_auth_success,
        on_auth_cleanup
    };

    Credentials credentials = {
        "cassandra",
        "cassandra"
    };

    // Add contact points
    if (argc > 1) {
        hosts = argv[1];
    }
    cass_cluster_set_contact_points(cluster, hosts);

    // Set custom authentication callbacks and credentials
    cass_cluster_set_authenticator_callbacks(cluster,
                                             &auth_callbacks,
                                             NULL,
                                             &credentials);

    // Provide the cluster object as configuration to connect the session
    connect_future = cass_session_connect(session, cluster);

    if (cass_future_error_code(connect_future) == CASS_OK) {
        CassFuture* close_future = NULL;

        printf("Successfully connected!\n");

        // Close the session
        close_future = cass_session_close(session);
        cass_future_wait(close_future);
        cass_future_free(close_future);
    } else {
        // Handle error
        const char* message;
        size_t message_length;
        cass_future_error_message(connect_future, &message, &message_length);
        fprintf(stderr, "Unable to connect: '%.*s'\n", (int)message_length,
                message);
    }

    cass_future_free(connect_future);
    cass_cluster_free(cluster);
    cass_session_free(session);

    return 0;
}
*/
